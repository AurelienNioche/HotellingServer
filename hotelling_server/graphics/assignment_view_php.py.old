import PyQt5.Qt as Qt5
from PyQt5.QtCore import Qt, QObject, QEvent, QSize
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QPushButton, QLabel, \
    QGridLayout, QButtonGroup, QHBoxLayout, QLineEdit, QCheckBox, QRadioButton, \
    QScrollArea, QMessageBox, QFormLayout, QDialog, QGroupBox, QTableWidget, QAbstractItemView, QTableWidgetItem
from threading import Timer

from utils.utils import Logger



class AssignmentFramePHP(Logger, QWidget):

    name = "AssignmentFramePHP"

    def __init__(self, parent, param):

        # noinspection PyArgumentList
        super().__init__(parent=parent)
        
        self.param = param

        self.layout = QVBoxLayout()

        self.next_button = QPushButton("Next")
        self.previous_button = QPushButton("Previous")
        self.scan_button = QPushButton("Look for new participants...")
        self.erase_tables_button = QPushButton("Erase SQL tables")

        self.group = QButtonGroup()

        self.group.addButton(self.previous_button)
        self.group.addButton(self.next_button)
        self.group.addButton(self.scan_button)
        self.group.addButton(self.erase_tables_button)
        
        # assignments widgets (list of game id, server id, role, bot)
        self.list_group = QGroupBox("Set assignments")
        self.list_widget = QWidget()
        self.list_scroll_area = QScrollArea()

        # self.timer = Timer(1000, self.update_table)

        self.n_player = self.param["game"]["n_customers"] + self.param["game"]["n_firms"]

        self.table = GameIdUserTable(parent=self.list_widget, 
                n_player=self.n_player, n_customer=self.param["game"]["n_customers"], n_firm=self.param["game"]["n_firms"],
                headers=("Game ID", "Username","Role", "Bot"))

        self.error = None

        self.setup()

    def setup(self):

        # --------- fill layout ----------------------------------- #

        self.fill_table()
        self.fill_layout()

        self.list_scroll_area.setFixedHeight(500)
        self.list_scroll_area.setFixedWidth(500)

        # noinspection PyUnresolvedReferences
        self.next_button.clicked.connect(self.push_next_button)
        # noinspection PyUnresolvedReferences
        self.previous_button.clicked.connect(self.push_previous_button)
        # noinspection PyUnresolvedReferences
        self.scan_button.clicked.connect(self.push_scan_button)
        # noinspection PyUnresolvedReferences
        self.erase_tables_button.clicked.connect(self.push_erase_tables_button)

    def fill_table(self):

        roles = \
            ["firm" for i in range(self.param["game"]["n_firms"])] \
            + ["customer" for i in range(self.param["game"]["n_customers"])]

        names = ["Bot" for i in range(self.n_player)]

        game_ids = list(range(self.n_player))

        bots = ["X" for i in range(self.n_player)]

        self.table.update(game_ids, names, roles, bots)

    def fill_layout(self):
        
        table_layout = QVBoxLayout()
        table_layout.addWidget(self.table)

        self.list_widget.setLayout(table_layout)
        self.list_scroll_area.setWidget(self.list_widget)

        list_scroll_area_layout = QHBoxLayout()
        list_scroll_area_layout.addWidget(self.list_scroll_area)

        self.list_group.setLayout(list_scroll_area_layout)

        self.layout.addWidget(self.list_group, alignment=Qt.AlignCenter)

        horizontal_layout = QHBoxLayout()
        horizontal_layout.addWidget(self.previous_button, alignment=Qt.AlignCenter)
        horizontal_layout.addWidget(self.next_button, alignment=Qt.AlignCenter)

        self.layout.addLayout(horizontal_layout)
        
        self.layout.addWidget(self.scan_button, alignment=Qt.AlignCenter)
        self.layout.addWidget(self.erase_tables_button, alignment=Qt.AlignCenter)

        self.setLayout(self.layout)

    def prepare(self):
        
        self.next_button.setEnabled(True)
        self.next_button.setFocus()
        self.setFocus()
    # ---------------------- PUSH BUTTONS --------------------------------- #

    def push_next_button(self):

        warning = self.check_assignment_validity()

        if warning:
            self.show_warning(msg=warning)

        else:
            self.log("Push 'next' button.")
                  
            self.param["assignment_php"] = self.get_assignment()
            self.parent().save_parameters("assignment_php", self.param["assignment_php"])
            self.parent().set_assignment(assignment=self.param["assignment_php"])
            self.parent().show_frame_parametrization()

    def push_previous_button(self):

        if self.error:

            self.show_warning(msg=self.error)

        else:
            self.log("Push 'previous' button.")
            self.parent().show_frame_load_game_new_game_php()

    def push_scan_button(self):

        self.scan_button.setEnabled(False)

        self.parent().php_scan_button()

    def push_erase_tables_button(self):

        self.erase_tables_button.setEnabled(False)

        self.parent().show_menubar_frame_erase_sql_tables()

        self.erase_tables_button.setEnabled(True)
    # ------------------------------------------------------------------------------- #

    def update_participants(self, participants):
        
        self.table.update(list(range(self.n_player)), participants)

        self.scan_button.setEnabled(True)

    def get_assignment(self):

        game_ids, names, roles, bots = self.table.get_data()

        assignment = [[int(game_id), name, role, bot] for game_id, name, role, bot in zip(game_ids, names, roles, bots)]

        return assignment
    
    # ----------------------------- assignment validity checking -------------------------------------------------- #

    def check_assignment_validity(self, **kwargs):

        assignment = list(enumerate(self.get_assignment()))

        for i, (game_id, server_id, role, bot) in assignment:

            for j, (other_game_id, other_server_id, other_role, other_bot) in assignment:

                if other_server_id == server_id and other_server_id != "Bot" and i != j:
                    return "Two identical server ids: '{}'.".format(server_id)

                if other_game_id == game_id and i != j:
                    return "Two identical game_id ids: '{}'.".format(game_id)

    # ----------------------------------------------------------------------------------------------------------------- #
            
    def show_warning(self, **instructions):

        QMessageBox().warning(
            self, "", instructions["msg"],
            QMessageBox.Ok
        )

    # --------------------------------- Widgets used in assignment menu --------------------------------- #

class AbstractTable(QTableWidget):

    """
    Model class for QTables
    """

    def __init__(self, parent, headers, n_player):

        super().__init__(parent=parent)

        self.columns_headers = headers

        self.n_player = n_player

        self.setup()

    def setup(self):

          # set height and width
        self.setColumnCount(len(self.columns_headers))
        self.setRowCount(self.n_player)

        # fit the widget
        self.setMaximumSize(self.get_size())
        self.setMinimumSize(self.get_size())
        self.verticalHeader().hide()
        self.verticalHeader().setSectionResizeMode(Qt5.QHeaderView.Stretch)
        
        # readonly
        self.setEditTriggers(QAbstractItemView.NoEditTriggers)

        # remove grid
        self.setShowGrid(False)

        # enable drag and drop
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDefaultDropAction(Qt.MoveAction)

        # disable scrollbar 
        self.verticalScrollBar().setDisabled(True);
        self.verticalScrollBar().hide()

        # set names
        for i, name in enumerate(self.columns_headers):
            self.setHorizontalHeaderItem(i, QTableWidgetItem(name))

    def update(self, *data):
        
        if data:
            self.fill_table(columns=data)

    def fill_table(self, columns):
        
        for y, items in enumerate(columns):
            
            for x, item in enumerate(items):
                self.setItem(x, y, QTableWidgetItem(str(item)))

    def is_already_in_table(self, item):

        return any([item in col for col in self.get_data()])

    def remove_selected_row(self):

        self.removeRow(self.currentRow())
        self.insertRow(self.rowCount())

    def get_data(self):

        return [[self.item(x, y).text() for x in range(self.rowCount()) if self.item(x, y)] 
                for y in range(self.columnCount())]

    def get_size(self):

        w = self.verticalHeader().width() + 4  # +4 seems to be needed
        for i in range(self.columnCount()):
            w += self.columnWidth(i)  # seems to include gridline (on my machine)

        h = self.horizontalHeader().height() + 4
        for i in range(self.rowCount()):
            h += self.rowHeight(i)

        return QSize(w, h)

    
class GameIdUserTable(AbstractTable):

    def __init__(self, parent, headers, n_player, n_firm, n_customer): 

        super().__init__(parent=parent, headers=headers, n_player=n_player)
        self.n_customer = n_customer
        self.n_firm = n_firm

        self.itemClicked.connect(self.set_to_bot)

    def get_dragged_item(self):

        return self.currentRow(), self.currentColumn()

    def reset_item(self, x, y, text):

        self.setItem(x, y, QTableWidgetItem(text))

    def correct_roles(self, x, y):

        n_firm = 0
        n_customer = 0 
        
        for role in self.get_data()[2]:
            n_customer += role == "customer"
            n_firm += role == "firm"
        
        if self.n_firm > n_firm:
            self.reset_item(x, y, "firm")
        else:
            self.reset_item(x, y, "customer")

    def set_to_bot(self):

        if self.currentItem().text() == "X":
            self.currentItem().setText("")
            self.setItem(self.currentRow(), 1, QTableWidgetItem(""))

        elif self.currentItem().text() == "":
            self.currentItem().setText("X")
            self.setItem(self.currentRow(), 1, QTableWidgetItem("Bot"))

    def dragEnterEvent(self, e):
        super().dragEnterEvent(e)
        self.old_item = self.get_dragged_item()

    def dropEvent(self, e):
        # self.reset_item(*self.old_item, text)
        super().dropEvent(e)
        self.correct_roles(*self.old_item)
       



